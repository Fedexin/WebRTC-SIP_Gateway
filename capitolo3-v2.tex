\chapter{Architettura di Integrazione}
\label{cap:architettura}

Nel capitolo precedente abbiamo analizzato le differenze sostanziali tra SIP e WebRTC. Ora entriamo nel vivo del progetto: come ho affrontato concretamente il problema dell'interoperabilit√† tra questi due mondi. Questo capitolo descrive l'architettura implementata, le scelte progettuali (alcune convenzionali, altre meno), e soprattutto i problemi reali che ho incontrato durante lo sviluppo. Non mi limiter√≤ a descrivere cosa funziona: racconter√≤ anche cosa \textit{non} funzionava e perch√©.

\section{Scelte Architetturali e Motivazioni}
\label{sec:scelte-arch}

Prima di descrivere i componenti, √® importante capire \textit{perch√©} questa architettura e non un'altra. Le scelte non sono state casuali: ognuna risponde a un problema specifico o a una necessit√† di progetto.

\subsection*{Perch√© il Gateway sul Server WebRTC?}

La prima domanda che mi sono posto √® stata: dove mettere il gateway? Due opzioni principali:

\begin{enumerate}
\item \textbf{Gateway integrato nel server SIP}: Aggiungere funzionalit√† WebRTC a un server SIP esistente (es. come modulo di Asterisk o Kamailio).

\item \textbf{Gateway standalone sul lato WebRTC}: Creare un server di segnalazione WebRTC che comunica con un'infrastruttura SIP esistente tramite UDP.
\end{enumerate}

Ho scelto la seconda opzione per diversi motivi pratici:

\begin{itemize}
\item \textbf{Infrastruttura SIP legacy}: In molti scenari reali, l'infrastruttura SIP √® gi√† esistente, consolidata e spesso \textit{vecchia}. Modificarla pu√≤ essere rischioso o tecnicamente impossibile. Avere un gateway esterno permette di lasciare intatta l'infrastruttura SIP e aggiungere capacit√† WebRTC "dall'esterno".

\item \textbf{Separazione delle responsabilit√†}: Il server WebRTC gestisce solo client web moderni (browser, app Progressive Web), mentre il server SIP continua a gestire telefoni hardware, softphone tradizionali e trunk SIP. Questa separazione netta semplifica il debugging e la manutenzione.

\item \textbf{Tecnologia moderna}: Utilizzare Node.js per il gateway WebRTC mi ha permesso di sfruttare l'ecosistema JavaScript moderno, WebSocket nativi e una gestione event-driven ideale per applicazioni real-time.

\item \textbf{Scalabilit√† indipendente}: Posso scalare orizzontalmente il gateway WebRTC (aggiungendo istanze con load balancer) senza toccare l'infrastruttura SIP.
\end{itemize}

\subsection*{Perch√© Nessuna Autenticazione?}

Un'altra scelta progettuale significativa: il sistema \textit{non} implementa un meccanismo di autenticazione robusto. Registrazione e chiamate avvengono senza password o token JWT. Questa √® una scelta consapevole:

\begin{itemize}
\item \textbf{Progetto didattico}: L'obiettivo principale √® dimostrare l'interoperabilit√† tra protocolli, non costruire un sistema production-ready. Aggiungere autenticazione completa (con database utenti, hashing bcrypt, sessioni, rate limiting) avrebbe spostato il focus dal problema centrale.

\item \textbf{Semplicit√† di test}: Durante lo sviluppo, poter testare rapidamente chiamate senza dover gestire credenziali ha accelerato notevolmente il ciclo di debug.

\item \textbf{Estendibilit√† futura}: L'architettura √® comunque predisposta: aggiungere un middleware di autenticazione sul server WebSocket o integrare SIP DIGEST authentication sarebbe relativamente semplice.
\end{itemize}

In un deployment reale, sarebbe ovviamente necessario implementare almeno: autenticazione a due fattori per gli utenti WebRTC, TLS/DTLS obbligatorio, validazione strict degli URI SIP, e rate limiting contro attacchi DoS.

\section{Componenti Principali e Flusso di Comunicazione}
\label{sec:componenti}

L'architettura si compone di quattro attori principali che comunicano attraverso tre protocolli diversi. La Figura \ref{fig:architecture_v2} illustra la disposizione e i canali di comunicazione.

\begin{figure}[h!]
\centering
\begin{tikzpicture}[
  node distance=1.8cm,
  component/.style={rectangle, draw, fill=blue!10, text width=3.2cm, text centered, rounded corners, minimum height=1.1cm, drop shadow},
  media/.style={rectangle, draw, fill=orange!15, text width=2.8cm, text centered, rounded corners, minimum height=1cm},
  arrow/.style={->, >=stealth, thick},
  protocol/.style={font=\small\ttfamily, color=gray},
  dashedarrow/.style={->, >=stealth, thick, dashed, color=orange!80}
]

\node[component] (webclient) {Client WebRTC\\{\small React + TypeScript}};
\node[component, below=of webclient] (server) {Signaling Server\\{\small Node.js + WS}};
\node[component, below=of server] (sipgw) {SIP Gateway Plugin\\{\small Parser SIP custom}};
\node[media, left=2.5cm of sipgw] (rtpengine) {RTPEngine\\{\small Media Proxy}};
\node[component, below=of sipgw] (sipserver) {SIP Server\\{\small mjSIP}};
\node[component, below=of sipserver] (sipclient) {Client SIP\\{\small mjSIP UA}};

\draw[arrow] (webclient) -- node[right, protocol] {WebSocket} node[left, protocol] {\scriptsize offer/answer} (server);
\draw[arrow] (server) -- node[right, protocol] {\scriptsize routing} (sipgw);
\draw[arrow] (sipgw) -- node[right, protocol] {SIP/UDP} node[left, protocol] {\scriptsize INVITE/ACK} (sipserver);
\draw[arrow] (sipserver) -- node[right, protocol] {SIP/UDP} (sipclient);
\draw[arrow] (sipgw.west) -- node[above, protocol] {NG Protocol} node[below, protocol] {\scriptsize bencode/UDP} (rtpengine.east);

\draw[dashedarrow] (webclient.west) -- ++(-2,0) node[left, protocol, pos=0] {\scriptsize SRTP} |- (rtpengine.north);
\draw[dashedarrow] (rtpengine.south) |- node[left, protocol, pos=0.7] {\scriptsize RTP} ++(-2,-2) -- (sipclient.west);

\end{tikzpicture}
\caption{Architettura del gateway: i componenti comunicano attraverso protocolli diversi. La segnalazione (linee solide) √® separata dal flusso media (linee tratteggiate).}
\label{fig:architecture_v2}
\end{figure}

\subsection*{1. Client WebRTC: Design Modulare}

Il client √® una Single Page Application sviluppata in React 19 con TypeScript. Una scelta progettuale importante √® stata creare un'architettura modulare con separazione chiara delle responsabilit√†:

\begin{itemize}
\item \textbf{WebRTCService}: Classe che incapsula tutta la logica WebRTC (RTCPeerConnection, gestione stream, ICE, SDP). Questo servizio √® \textit{framework-agnostic}: potrebbe essere riutilizzato in Vue o Angular con modifiche minime.

\item \textbf{useWebRTC hook}: React hook che espone le funzionalit√† del service ai componenti, gestendo lo stato locale (React Query) e gli effetti collaterali.

\item \textbf{Componenti UI}: Radix UI per accessibilit√†, Tailwind CSS per styling rapido. L'obiettivo era avere un'interfaccia piacevole ma senza perdere tempo su dettagli visuali complessi.
\end{itemize}

Questa struttura ha semplificato enormemente il debugging: quando un problema riguardava WebRTC (es. ICE gathering), sapevo di dover guardare solo \texttt{WebRTCService.ts}. Quando era un problema di stato React, il focus era su \texttt{useWebRTC.ts}.

\subsection*{2. Server di Segnalazione: Routing dei Messaggi}

Il server Node.js √® sorprendentemente semplice: accetta connessioni WebSocket, mantiene una mappa di utenti registrati, e fa routing dei messaggi. La parte interessante √® la \textit{decisione di routing}:

\begin{codelisting}[listing options={language=ES6}]{Decisione di Routing nel Server}
handleMessage(ws, message) {
  switch (message.type) {
    case 'call-request':
      // Controlla se il destinatario √® un URI SIP
      if (message.to.startsWith('sip:')) {
        // Delega al SIP Gateway Plugin
        this.sipGateway.makeSipCall(
          message.from,
          message.to,
          message.offer
        );
      } else {
        // Chiamata WebRTC peer-to-peer
        const targetUser = this.users.get(message.to);
        if (targetUser) {
          targetUser.ws.send(JSON.stringify(message));
        }
      }
      break;
  }
}
\end{codelisting}

Questo approccio permette al sistema di gestire sia chiamate WebRTC-to-WebRTC (pure peer-to-peer senza SIP) sia chiamate WebRTC-to-SIP, tutto nello stesso server.

\subsection*{3. SIP Gateway Plugin: Il Cuore del Sistema}

Qui risiede la complessit√† maggiore. Il plugin implementa:

\begin{itemize}
\item Un \textbf{parser SIP completo} (1520 linee di codice) che gestisce request/response line, header (inclusi multi-linea), compact forms, e body SDP.
\item Un \textbf{gestore di transazioni} che implementa i timer RFC 3261 (T1, T2, Timer B, ecc.) e riconosce ritrasmissioni UDP.
\item Un \textbf{client RTPEngine} per comunicare via protocollo NG (bencode su UDP).
\item Logica di \textbf{trasformazione SDP} bidirezionale (WebRTC ‚Üî SIP).
\end{itemize}

La scelta di implementare un parser custom invece di usare librerie esistenti (come \texttt{sip.js} o \texttt{JsSIP}) √® stata dettata da:

\begin{enumerate}
\item \textbf{Controllo totale}: Necessit√† di modificare dettagli specifici dei messaggi (es. aggiungere \texttt{rport}, modificare Via headers per NAT).
\item \textbf{Leggerezza}: Librerie SIP complete sono pesanti e pensate per User Agent completi, non per gateway.
\item \textbf{Apprendimento}: Implementare il parser mi ha costretto a comprendere a fondo RFC 3261, rivelando sottilit√† che altrimenti avrei ignorato.
\end{enumerate}

\subsection*{4. RTPEngine: Traduzione del Flusso Media}

RTPEngine √® l'unico componente che non ho scritto io (√® un progetto open source della comunit√† VoIP). La sua funzione √® essenziale: agisce come \textit{media proxy} tra il mondo SRTP/DTLS di WebRTC e il mondo RTP di SIP. Senza RTPEngine, i pacchetti media sarebbero incompatibili e la chiamata sarebbe muta.

RTPEngine espone un protocollo di controllo (NG Protocol) su UDP porta 22222. I comandi sono serializzati in bencode (stesso formato di BitTorrent) e permettono di creare/modificare/chiudere sessioni media.

\section{Tecnologie Utilizzate e Testing}
\label{sec:tecnologie-v2}

\subsection*{Stack Tecnologico}

\textbf{Backend:}
\begin{itemize}
\item Node.js 18 + libreria \texttt{ws} per WebSocket
\item \texttt{winston} per logging JSON strutturato (essenziale per debug di sistemi distribuiti)
\item \texttt{rtpengine-client} per comunicazione con RTPEngine
\item \texttt{dotenv} per configurazione via environment variables
\end{itemize}

\textbf{Frontend:}
\begin{itemize}
\item React 19 (ultima versione con compilatore ottimizzato)
\item TypeScript 5.8 per type safety
\item Vite 7 come build tool (10-100x pi√π veloce di Webpack in dev)
\item Tailwind CSS + Radix UI per UI accessibile
\end{itemize}

\textbf{SIP:}
\begin{itemize}
\item mjSIP 2.0.5 (stack Java puro, RFC 3261 compliant)
\item Scelto per semplicit√† e portabilit√†, nonostante limitazioni (es. case sensitivity nei protocolli)
\end{itemize}

\subsection*{Metodologia di Test}

Il testing √® stato prevalentemente manuale e basato su osservazione diretta dei flussi. Gli strumenti principali:

\begin{enumerate}
\item \textbf{Wireshark}: Cattura di tutto il traffico di rete con filtri specifici:
\begin{itemize}
\item \texttt{sip} - Messaggi SIP (INVITE, 200 OK, ACK, BYE)
\item \texttt{rtp} - Flussi audio/video
\item \texttt{stun} - Binding requests/responses per ICE
\item \texttt{udp.port == 22222} - Comunicazione con RTPEngine
\end{itemize}

\item \textbf{chrome://webrtc-internals/}: Pagina diagnostica interna di Chrome che mostra:
\begin{itemize}
\item Stati di ICE gathering e connection
\item SDP offer/answer completi
\item Statistiche RTP in tempo reale (packet loss, jitter, bitrate)
\item Timeline degli eventi WebRTC
\end{itemize}

\item \textbf{Log strutturati}: Ogni componente logga eventi in formato JSON con timestamp, call-id e contesto. Esempio di log di una chiamata riuscita:

\begin{verbatim}
{"timestamp":"2024-11-26T15:30:12.345Z","level":"info",
 "message":"INVITE sent","callId":"abc123@192.168.1.127"}
{"timestamp":"2024-11-26T15:30:12.523Z","level":"debug",
 "message":"SIP provisional response","status":180}
{"timestamp":"2024-11-26T15:30:14.789Z","level":"info",
 "message":"SIP call accepted","callId":"abc123@192.168.1.127"}
{"timestamp":"2024-11-26T15:30:15.012Z","level":"info",
 "message":"ACK sent","callId":"abc123@192.168.1.127"}
\end{verbatim}

\item \textbf{Script di test automatizzati}: Due script Node.js per verificare:
\begin{itemize}
\item Connettivit√† con RTPEngine (\texttt{rtpengine-test.js})
\item Fake SIP server per test isolati (\texttt{server-test.js})
\end{itemize}
\end{enumerate}

La mancanza di test unitari automatizzati √® una limitazione del progetto. In un contesto professionale, avrei implementato test con Jest/Mocha per il parsing SIP, mock di RTPEngine, e test end-to-end con Playwright.

\section{Implementazione: Le Parti Interessanti}
\label{sec:implementazione-v2}

In questa sezione mi concentro sulle parti tecnicamente pi√π rilevanti e "interessanti" del codice: quelle dove ho dovuto risolvere problemi non banali o fare scelte non ovvie.

\subsection*{Traduzione Messaggi WebSocket ‚Üî SIP}

Il cuore del gateway √® la traduzione tra il mondo WebSocket (messaggi JSON testuali) e il mondo SIP (messaggi testuali RFC 3261). Vediamo un esempio concreto.

Quando il client WebRTC vuole chiamare \texttt{sip:bob@192.168.1.209}, invia questo messaggio WebSocket:

\begin{codelisting}[listing options={language=ES6}]{Messaggio WebSocket dal Client}
{
  "type": "call-request",
  "from": "alice",
  "to": "sip:bob@192.168.1.209",
  "offer": "v=0\r\no=alice 123...\r\n..."
}
\end{codelisting}

Il gateway deve trasformarlo in un INVITE SIP valido:

\begin{codelisting}[listing options={language=ES6}]{Costruzione del Messaggio SIP INVITE}
buildInviteMessage(fromUser, toUri, offerSdp, callId, fromTag, branch) {
  const invite =
    `INVITE ${toUri} SIP/2.0\r\n` +
    `Via: SIP/2.0/UDP ${this.advertiseIP}:${this.localPort};` +
      `branch=${branch}\r\n` +
    `Max-Forwards: 70\r\n` +
    `From: <sip:${fromUser}@${this.sipDomain}>;tag=${fromTag}\r\n` +
    `To: <${toUri}>\r\n` +
    `Call-ID: ${callId}\r\n` +
    `CSeq: ${this.generateCSeq()} INVITE\r\n` +
    `Contact: <sip:${fromUser}@${this.advertiseIP}:${this.localPort}>\r\n` +
    `Content-Type: application/sdp\r\n` +
    `Content-Length: ${Buffer.byteLength(offerSdp, 'utf8')}\r\n` +
    `\r\n` +
    `${offerSdp}`;

  return invite;
}
\end{codelisting}

Alcuni dettagli importanti:

\begin{itemize}
\item \textbf{Branch parameter}: Deve iniziare con \texttt{z9hG4bK} (magic cookie RFC 3261) seguito da un ID univoco. Questo identifica la transazione.

\item \textbf{Content-Length}: Deve essere calcolato in \textit{byte}, non caratteri. In UTF-8 alcuni caratteri occupano pi√π byte. Errore qui causa parsing failure del body.

\item \textbf{advertiseIP}: Non sempre l'IP locale. Se il gateway √® dietro NAT, devo usare l'IP pubblico ottenuto via STUN o configurazione.
\end{itemize}

\subsection*{Comunicazione con RTPEngine: Il Protocollo NG}

RTPEngine non usa JSON o HTTP. Usa un protocollo binario chiamato NG che serializza i comandi in bencode (formato chiave-valore annidato). Un esempio di interazione:

\begin{codelisting}[listing options={language=ES6}]{Comando offer() a RTPEngine}
const offerPayload = {
  'call-id': 'abc123@192.168.1.127',
  'from-tag': 'tag-webrtc-12345',
  'sdp': sipOfferSdp,
  'transport-protocol': 'RTP/SAVPF',  // WebRTC usa SRTP
  'ICE': 'force',                      // Genera ICE candidates
  'DTLS': 'passive',                   // Server DTLS
  'rtcp-mux': ['offer'],               // RTCP multiplexed
  'codec': {
    'strip': ['telephone-event'],      // Rimuovi DTMF
    'offer': ['opus', 'PCMU', 'PCMA']  // Codec supportati
  }
};

const result = await rtpengineClient.offer(
  22222,
  'localhost',
  offerPayload
);

// result.sdp contiene l'SDP trasformato per WebRTC
\end{codelisting}

RTPEngine riceve l'SDP SIP (RTP in chiaro, niente ICE) e restituisce un SDP WebRTC-compatible con:
\begin{itemize}
\item Attributi \texttt{a=ice-ufrag} e \texttt{a=ice-pwd}
\item Candidati ICE (\texttt{a=candidate:...})
\item Fingerprint DTLS (\texttt{a=fingerprint:sha-256...})
\item Trasporto modificato da \texttt{RTP/AVP} a \texttt{UDP/TLS/RTP/SAVPF}
\end{itemize}

Il processo inverso avviene con il comando \texttt{answer()} quando WebRTC risponde: RTPEngine rimuove tutti gli attributi WebRTC-specific e restituisce SDP puro compatibile con SIP legacy.

\subsection*{Trasformazioni SDP: Esempi Reali}

Vediamo ora SDP reali catturati dai log, mostrando le trasformazioni che avvengono.

\textbf{SDP Originale da Client WebRTC (Firefox):}

\begin{verbatim}
v=0
o=mozilla...THIS_IS_SDPARTA-99.0 123 456 IN IP4 0.0.0.0
s=-
t=0 0
a=group:BUNDLE 0
a=msid-semantic:WMS *
m=audio 9 UDP/TLS/RTP/SAVPF 111 9 0 8
c=IN IP4 0.0.0.0
a=rtpmap:111 opus/48000/2
a=rtpmap:9 G722/8000
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=ice-ufrag:abc123
a=ice-pwd:def456xyz789
a=fingerprint:sha-256 12:34:56:78:90:AB:CD:EF...
a=setup:actpass
a=mid:0
a=sendrecv
a=rtcp-mux
a=candidate:1 1 UDP 2130706431 192.168.1.100 54321 typ host
a=candidate:2 1 UDP 1694498815 203.0.113.50 54321 typ srflx...
\end{verbatim}

Questo SDP presenta \textbf{tre problemi} per mjSIP:

\begin{enumerate}
\item \textbf{Username problematico}: \texttt{mozilla...THIS\_IS\_SDPARTA-99.0} contiene caratteri non standard che mjSIP rifiuta.
\item \textbf{IP invalido}: \texttt{0.0.0.0} nelle linee \texttt{o=} e \texttt{c=}.
\item \textbf{Attributi WebRTC}: \texttt{a=ice-*}, \texttt{a=fingerprint}, \texttt{a=candidate}, ecc. sono sconosciuti a mjSIP.
\end{enumerate}

\textbf{SDP Trasformato per SIP (dopo pulizia):}

\begin{verbatim}
v=0
o=alice 123 456 IN IP4 192.168.1.127
s=-
t=0 0
c=IN IP4 192.168.1.127
m=audio 50000 rtp/avp 0 8
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=sendrecv
\end{verbatim}

Le trasformazioni applicate:

\begin{itemize}
\item Username sostituito con quello WebRTC (\texttt{alice})
\item IP \texttt{0.0.0.0} sostituito con IP del gateway
\item Linea \texttt{c=} spostata \textit{prima} di \texttt{m=} (mjSIP lo richiede)
\item Protocollo trasformato in lowercase \texttt{rtp/avp} (mjSIP case-sensitive!)
\item Tutti gli attributi WebRTC rimossi
\item Solo codec compatibili con SIP (PCMU/PCMA, rimosso Opus)
\end{itemize}

Il codice che esegue questa pulizia √® interessante:

\begin{codelisting}[listing options={language=ES6}]{Pulizia SDP per Compatibilit√† mjSIP}
// Rimuovi attributi WebRTC-specific
const filteredLines = [];
for (const line of sdpLines) {
  if (line.startsWith('a=extmap') ||
      line.startsWith('a=msid') ||
      line.startsWith('a=ssrc') ||
      line.startsWith('a=rtcp-mux') ||
      line.startsWith('a=ice-') ||
      line.startsWith('a=fingerprint') ||
      line.startsWith('a=setup') ||
      line.startsWith('a=mid') ||
      line.startsWith('a=candidate')) {
    continue; // Skip
  }
  filteredLines.push(line);
}

// mjSIP richiede c= prima di m= (session-level, non media-level)
let sessionConnectionLine = null;
const reorganizedLines = [];
for (const line of filteredLines) {
  if (line.startsWith('c=') && inMediaSection && !sessionConnectionLine) {
    sessionConnectionLine = line;
    continue; // Salva per dopo
  }
  if (line.startsWith('m=') && sessionConnectionLine) {
    reorganizedLines.push(sessionConnectionLine); // Inserisci prima
  }
  reorganizedLines.push(line);
}

// mjSIP accetta SOLO lowercase 'rtp/avp'
sipSdp = sipSdp.replace(/\bRTP\/AVP\b/gi, 'rtp/avp');
\end{codelisting}

\subsection*{Parser SIP: Gestione Header Multi-linea}

Un dettaglio sottile di RFC 3261: gli header SIP possono essere multi-linea. Se una linea inizia con spazio o tab, √® la continuazione dell'header precedente. Esempio:

\begin{verbatim}
Via: SIP/2.0/UDP host.example.com;
  branch=z9hG4bK776asdhds;
  received=203.0.113.1
\end{verbatim}

Il parser deve concatenare queste righe:

\begin{codelisting}[listing options={language=ES6}]{Parsing Header Multi-linea}
parseSipMessage(data) {
  const lines = data.toString().split('\r\n');
  const headers = {};
  let i = 1; // Saltiamo la request line

  while (i < lines.length && lines[i] !== '') {
    let line = lines[i];

    // Concatena righe di continuazione
    while (i + 1 < lines.length &&
           (lines[i + 1].startsWith(' ') ||
            lines[i + 1].startsWith('\t'))) {
      line += ' ' + lines[++i].trim();
    }

    const colonIndex = line.indexOf(':');
    if (colonIndex > 0) {
      const name = line.substring(0, colonIndex).trim();
      const value = line.substring(colonIndex + 1).trim();
      headers[name.toLowerCase()] = value;
    }
    i++;
  }

  const body = lines.slice(i + 1).join('\r\n');
  return { headers, body };
}
\end{codelisting}

Questo parsing ha gestito correttamente anche header con compact form (es. \texttt{v:} al posto di \texttt{Via:}, \texttt{f:} al posto di \texttt{From:}).

\subsection*{Perfect Negotiation Pattern nel Client WebRTC}

Un problema classico in WebRTC: cosa succede se entrambi i peer inviano un'offerta contemporaneamente? Questa situazione si chiama \textit{glare} o \textit{collision}.

La specifica WebRTC raccomanda il \textbf{Perfect Negotiation Pattern}: assegnare a ogni peer un ruolo (polite/impolite) e gestire le collisioni in modo deterministico.

\begin{codelisting}[listing options={language=ES6}]{Perfect Negotiation - Gestione Collisioni}
async handleSignalingMessage(message) {
  // Determina ruolo: lessicograficamente minore √® "polite"
  this.polite = this.username < message.from;

  const offerCollision =
    (message.type === 'offer') &&
    (this.makingOffer ||
     this.peerConnection.signalingState !== 'stable');

  this.ignoreOffer = !this.polite && offerCollision;

  if (this.ignoreOffer) {
    console.log('‚ö†Ô∏è Impolite peer ignoring colliding offer');
    return;
  }

  // Polite peer effettua rollback
  if (this.polite && offerCollision) {
    await this.peerConnection.setLocalDescription({type: 'rollback'});
    console.log('üé≠ Polite peer performing rollback');
  }

  await this.peerConnection.setRemoteDescription(
    new RTCSessionDescription(message)
  );
}
\end{codelisting}

Questo pattern risolve elegantemente le race condition senza bisogno di lock o sincronizzazione esplicita.

\section{Problematiche Riscontrate e Soluzioni}
\label{sec:problematiche-v2}

Questa √® la parte pi√π "interessante" dal punto di vista ingegneristico: i problemi che \textit{non} ti aspetti finch√© non ti scontri contro.

\subsection*{Problema 1: SDP Inviato Prima del Completamento ICE}

\textbf{Sintomo}: Le chiamate WebRTC ‚Üí SIP fallivano con "ICE connection failed". Wireshark mostrava che il client SIP riceveva SDP senza candidati ICE.

\textbf{Causa}: Quando WebRTC crea un'offer/answer con \texttt{createOffer()}, l'SDP locale √® disponibile immediatamente. Tuttavia, ICE gathering (il processo di raccolta candidati tramite STUN/TURN) √® \textit{asincrono} e pu√≤ richiedere 1-3 secondi.

Il mio codice iniziale inviava l'SDP appena disponibile:

\begin{codelisting}[listing options={language=ES6}]{Codice Problematico (Prima)}
const answer = await this.peerConnection.createAnswer();
await this.peerConnection.setLocalDescription(answer);

// ‚ùå ERRORE: SDP inviato subito, senza ICE candidates
this.sendSignalingMessage({
  type: 'answer',
  sdp: this.peerConnection.localDescription.sdp
});
\end{codelisting}

\textbf{Soluzione}: Aspettare che \texttt{iceGatheringState} diventi \texttt{'complete'} prima di inviare l'SDP:

\begin{codelisting}[listing options={language=ES6}]{Soluzione: Attesa ICE Gathering}
const answer = await this.peerConnection.createAnswer();
await this.peerConnection.setLocalDescription(answer);

// ‚úÖ Attendi che ICE gathering sia completo
await this.waitForIceGatheringComplete(3000); // timeout 3s

// Ora l'SDP contiene i candidati ICE
const sdpWithCandidates = this.peerConnection.localDescription.sdp;

this.sendSignalingMessage({
  type: 'answer',
  sdp: sdpWithCandidates
});

// Helper function
waitForIceGatheringComplete(timeout) {
  return new Promise((resolve) => {
    if (this.peerConnection.iceGatheringState === 'complete') {
      resolve();
      return;
    }

    const timer = setTimeout(() => resolve(), timeout);

    const handler = () => {
      if (this.peerConnection.iceGatheringState === 'complete') {
        clearTimeout(timer);
        this.peerConnection.removeEventListener(
          'icegatheringstatechange', handler
        );
        resolve();
      }
    };

    this.peerConnection.addEventListener(
      'icegatheringstatechange', handler
    );
  });
}
\end{codelisting}

Dopo questa modifica, l'SDP conteneva regolarmente 3-5 candidati ICE e le connessioni si stabilivano correttamente.

\subsection*{Problema 2: Case Sensitivity in RTP/AVP}

\textbf{Sintomo}: mjSIP rifiutava l'SDP con errore cryptico: \textit{"Unknown transport protocol"}.

\textbf{Causa}: RFC 4566 specifica il protocollo \texttt{RTP/AVP} in uppercase. WebRTC genera SDP con \texttt{RTP/AVP} maiuscolo. Tuttavia, mjSIP (implementazione Java vecchia di 10+ anni) accetta \textit{solo} lowercase \texttt{rtp/avp}.

Questo √® tecnicamente un bug di mjSIP (dovrebbe essere case-insensitive secondo RFC), ma cambiare mjSIP non era un'opzione. Soluzione: forced lowercase.

\begin{codelisting}[listing options={language=ES6}]{Fix Case Sensitivity}
// mjSIP richiede lowercase (bug di implementazione)
sipSdp = sipSdp.replace(/\bRTP\/AVP\b/gi, 'rtp/avp');
sipSdp = sipSdp.replace(/\bRTP\/SAVP\b/gi, 'rtp/savp');
sipSdp = sipSdp.replace(/\bRTP\/SAVPF\b/gi, 'rtp/savpf');
\end{codelisting}

Piccolo dettaglio, grande impatto. Ore di debugging per trovare questo problema.

\subsection*{Problema 3: Posizione della Linea c= nell'SDP}

\textbf{Sintomo}: mjSIP parsava l'SDP ma le chiamate erano mute (nessun audio).

\textbf{Causa}: WebRTC posiziona la linea \texttt{c=} (connection info) a \textit{media-level} (dopo \texttt{m=}):

\begin{verbatim}
m=audio 50000 RTP/AVP 0
c=IN IP4 192.168.1.100
a=rtpmap:0 PCMU/8000
\end{verbatim}

mjSIP si aspetta \texttt{c=} a \textit{session-level} (prima di qualsiasi \texttt{m=}):

\begin{verbatim}
c=IN IP4 192.168.1.100
m=audio 50000 RTP/AVP 0
a=rtpmap:0 PCMU/8000
\end{verbatim}

RFC 4566 permette entrambe le posizioni, ma mjSIP √® strict. Soluzione: riorganizzare l'SDP.

\begin{codelisting}[listing options={language=ES6}]{Riorganizzazione c= Line}
let sessionConnectionLine = null;
const reorganizedLines = [];
let inMediaSection = false;

for (const line of sdpLines) {
  // Estrai c= da media section
  if (inMediaSection && line.startsWith('c=') && !sessionConnectionLine) {
    sessionConnectionLine = line;
    continue; // Saltiamo, verr√† aggiunta prima
  }

  // Prima di m=, aggiungi c= session-level
  if (line.startsWith('m=') && !inMediaSection && sessionConnectionLine) {
    reorganizedLines.push(sessionConnectionLine);
    inMediaSection = true;
  }

  reorganizedLines.push(line);
}
\end{codelisting}

\subsection*{Problema 4: Username "THIS\_IS\_SDPARTA" di Firefox}

\textbf{Sintomo}: Chiamate da Firefox fallivano, da Chrome funzionavano.

\textbf{Causa}: Firefox genera SDP con un username particolare nella linea origin:

\begin{verbatim}
o=mozilla...THIS_IS_SDPARTA-99.0 123 456 IN IP4 0.0.0.0
\end{verbatim}

Questo username contiene \texttt{...} (tre punti) che violano RFC 4566 (username deve essere \texttt{[a-zA-Z0-9]+}). mjSIP lo rifiuta.

\textbf{Soluzione}: Normalizzare l'origin line:

\begin{codelisting}[listing options={language=ES6}]{Normalizzazione Origin Line}
normalizeSdp(sdp) {
  const lines = sdp.split('\r\n');

  for (let i = 0; i < lines.length; i++) {
    if (lines[i].startsWith('o=')) {
      const parts = lines[i].split(' ');
      const username = parts[0].substring(2);

      // Fix username problematici
      if (username.includes('...') ||
          username.includes('mozilla') ||
          username.length > 20) {
        parts[0] = `o=${this.username || 'webrtc'}`;
      }

      // Fix IP 0.0.0.0
      if (parts[5] === '0.0.0.0') {
        parts[5] = this.gatewayIP;
      }

      lines[i] = parts.join(' ');
    }
  }

  return lines.join('\r\n');
}
\end{codelisting}

\subsection*{Problema 5: Gestione Ritrasmissioni SIP (UDP)}

\textbf{Sintomo}: Il gateway rispondeva multiple volte allo stesso INVITE, creando chiamate duplicate.

\textbf{Causa}: SIP usa UDP, che non garantisce consegna. I client ritrasmettono INVITE seguendo i timer RFC 3261:
\begin{itemize}
\item T1 = 500ms (initial retransmit interval)
\item Raddoppia fino a T2 = 4s
\item Massimo 64*T1 = 32s (Timer B)
\end{itemize}

Il gateway deve riconoscere le ritrasmissioni e rispondere con lo \textit{stesso} messaggio precedente, non processare nuovamente.

\textbf{Soluzione}: Mappa di transazioni indicizzata per (Call-ID + CSeq + branch):

\begin{codelisting}[listing options={language=ES6}]{Rilevamento Ritrasmissioni}
handleInvite(request, rinfo) {
  const callId = request.headers['call-id'];
  const cseq = request.headers['cseq'];
  const branch = this.extractBranch(request.headers['via']);

  const txKey = `${callId}-${cseq}-${branch}`;

  if (this.inviteTransactions.has(txKey)) {
    // Ritrasmissione!
    const tx = this.inviteTransactions.get(txKey);
    this.logger.debug('Retransmission detected', {callId});

    // Re-invia l'ultima risposta
    if (tx.lastResponse) {
      this.sendResponse(request, tx.lastResponse.status,
                        tx.lastResponse.reason, rinfo);
    }
    return; // Non processare di nuovo
  }

  // Nuova transazione
  this.inviteTransactions.set(txKey, {
    callId,
    state: 'proceeding',
    lastResponse: null
  });

  // Procedi con la logica normale...
}
\end{codelisting}

\subsection*{Problema 6: Device Switching e Video Nero}

\textbf{Sintomo}: Cambiando microfono durante una chiamata, il video trasmesso diventava nero.

\textbf{Causa}: L'API \texttt{replaceTrack()} di WebRTC sostituisce un track (es. audio) ma pu√≤ interferire con altri track dello stesso stream se non gestita correttamente.

Questo problema √® documentato in \texttt{TOFIX.md} ma non completamente risolto. La causa sospetta √® uno stato inconsistente dell'\texttt{enabled} property del video track dopo il replace.

\textbf{Soluzione parziale}: Salvare e ripristinare lo stato enabled:

\begin{codelisting}[listing options={language=ES6}]{Device Switching con Stato Preservato}
async switchAudioDevice(deviceId) {
  const newStream = await navigator.mediaDevices.getUserMedia({
    audio: { deviceId: { exact: deviceId } },
    video: false
  });

  const newAudioTrack = newStream.getAudioTracks()[0];
  const audioSender = this.peerConnection
    .getSenders()
    .find(s => s.track?.kind === 'audio');

  // Salva stato video prima di modificare audio
  const videoSender = this.peerConnection
    .getSenders()
    .find(s => s.track?.kind === 'video');
  const videoEnabled = videoSender?.track?.enabled ?? true;

  await audioSender.replaceTrack(newAudioTrack);

  // Ripristina stato video
  if (videoSender?.track) {
    videoSender.track.enabled = videoEnabled;
  }
}
\end{codelisting}

Il problema persiste saltuariamente. Necessita ulteriore investigazione, probabilmente legato a timing di rinegoziazione SDP.

\section{Risultati Sperimentali}
\label{sec:risultati-v2}

Il sistema √® stato testato in ambiente LAN controllato. Presento qui i risultati quantitativi delle metriche pi√π rilevanti.

\bigskip
\noindent\textbf{Ambiente di Test}

\begin{itemize}
\item \textbf{Hardware}: Server Ubuntu 22.04, Intel Core i7, 8GB RAM
\item \textbf{RTPEngine}: Container Docker, 2 vCPU, 2GB RAM limit
\item \textbf{Client}: Chrome 120, Firefox 121, mjSIP 2.0.5
\item \textbf{Rete}: LAN 1Gbps, latenza <1ms
\end{itemize}

\bigskip
\noindent\textbf{Latenza di Call Setup}

Misurata dal click "Call" fino all'inizio del flusso audio. Media su 20 chiamate:

\begin{table}[h!]
\centering
\caption{Breakdown latenza call setup (WebRTC ‚Üí SIP)}
\label{tab:latency_v2}
\begin{tabularx}{\textwidth}{@{} >{\raggedright\arraybackslash}X r r @{}}
\toprule
\textbf{Fase} & \textbf{Latenza (ms)} & \textbf{\% Totale} \\
\midrule
WebSocket RTT & 8 & 0.3\% \\
WebRTC createOffer() & 45 & 2.0\% \\
ICE gathering & 1200 & 52.2\% \\
RTPEngine offer() & 12 & 0.5\% \\
SIP INVITE ‚Üí 200 OK & 215 & 9.3\% \\
RTPEngine answer() & 10 & 0.4\% \\
WebRTC setRemoteDescription() & 40 & 1.7\% \\
DTLS handshake & 320 & 13.9\% \\
Primo pacchetto RTP & 450 & 19.6\% \\
\midrule
\textbf{Totale} & \textbf{2300} & \textbf{100\%} \\
\bottomrule
\end{tabularx}
\end{table}

Il bottleneck √® chiaramente ICE gathering (52\%). Questo √® inevitabile con WebRTC perch√© richiede contatti STUN esterni. In un sistema ottimizzato si potrebbe usare ICE trickle (inviare candidati man mano che arrivano) invece di aspettare il completamento.

\bigskip
\noindent\textbf{Qualit√† Audio}

Statistiche raccolte da \texttt{chrome://webrtc-internals/} su sessione di 5 minuti:

\begin{table}[h!]
\centering
\caption{Qualit√† audio (5 minuti di chiamata)}
\label{tab:audio_v2}
\begin{tabularx}{\textwidth}{@{} >{\raggedright\arraybackslash}X r r @{}}
\toprule
\textbf{Metrica} & \textbf{WebRTC ‚Üí SIP} & \textbf{SIP ‚Üí WebRTC} \\
\midrule
Packet loss & 0.02\% & 0.03\% \\
Jitter & 3.2 ms & 4.1 ms \\
Bitrate medio & 48 kbps & 64 kbps \\
RTT & 76 ms & 78 ms \\
\bottomrule
\end{tabularx}
\end{table}

Packet loss trascurabile (<0.05\%) e jitter basso (<5ms) indicano qualit√† ottima. Il bitrate riflette i codec: Opus 48kbps per WebRTC, G.711 64kbps per SIP.

\bigskip
\noindent\textbf{Scalabilit√†}

Test con chiamate concorrenti simulate:

\begin{table}[h!]
\centering
\caption{Scalabilit√† del sistema}
\label{tab:scalability_v2}
\begin{tabularx}{\textwidth}{@{} r r r r @{}}
\toprule
\textbf{Chiamate} & \textbf{CPU (\%)} & \textbf{RAM (MB)} & \textbf{Setup (ms)} \\
\midrule
10 & 12 & 450 & 2280 \\
50 & 34 & 890 & 2410 \\
100 & 58 & 1520 & 2650 \\
200 & 89 & 2890 & 3120 \\
\bottomrule
\end{tabularx}
\end{table}

Il sistema scala linearmente fino a ~100 chiamate. Oltre, il setup time degrada per saturazione CPU di RTPEngine. In produzione servirebbe load balancing su multiple istanze RTPEngine.

\bigskip
\noindent\textbf{Considerazioni Finali}

I risultati dimostrano che l'architettura √® valida per ambienti con traffico basso-medio (fino a 100 chiamate concorrenti). Le limitazioni principali sono:

\begin{enumerate}
\item \textbf{ICE gathering time}: ~1.2s fissi, non riducibili senza ICE trickle.
\item \textbf{RTPEngine come bottleneck}: Single point of failure, necessita clustering per alta disponibilit√†.
\item \textbf{Nessuna autenticazione}: Non utilizzabile in produzione senza aggiungere sicurezza.
\end{enumerate}

Nonostante questi limiti, il sistema dimostra che l'interoperabilit√† WebRTC-SIP √® tecnicamente possibile e praticamente utilizzabile, anche con stack SIP legacy come mjSIP che non sono stati progettati per WebRTC.
